<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Factoría Estudio — Network Graph</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #030712; overflow: hidden; font-family: 'Inter', sans-serif; cursor: grab; }
        body.dragging { cursor: grabbing; }
        canvas { display: block; }

        #tooltip {
            position: fixed; pointer-events: none;
            background: rgba(15, 23, 42, 0.95); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px; padding: 14px 18px; color: #e2e8f0;
            max-width: 260px; opacity: 0; transition: opacity 0.15s; z-index: 100;
            backdrop-filter: blur(12px); box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }
        #tooltip.visible { opacity: 1; }
        #tooltip .cat { font-family: 'JetBrains Mono', monospace; font-size: 10px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        #tooltip .title { font-weight: 600; font-size: 15px; color: #f1f5f9; }
        #tooltip .desc { margin-top: 6px; font-size: 12px; line-height: 1.6; color: #94a3b8; }
        #tooltip .badge { display: inline-block; margin-top: 8px; font-family: 'JetBrains Mono', monospace; font-size: 10px; padding: 2px 8px; border-radius: 6px; background: rgba(255,255,255,0.06); color: #64748b; }

        #header {
            position: fixed; top: 0; left: 0; right: 0; padding: 20px 28px;
            z-index: 50; background: linear-gradient(to bottom, rgba(3,7,18,0.95) 0%, rgba(3,7,18,0.6) 70%, transparent);
            pointer-events: none;
        }
        #header h1 { font-size: 22px; font-weight: 300; color: #e2e8f0; }
        #header h1 span { color: #fbbf24; font-weight: 600; }
        #header .sub { font-family: 'JetBrains Mono', monospace; font-size: 11px; color: #475569; margin-top: 4px; }

        #legend {
            position: fixed; top: 80px; right: 20px; z-index: 50;
            background: rgba(15,23,42,0.6); border-radius: 12px; padding: 12px 16px;
            backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.05);
        }
        .legend-item {
            display: flex; align-items: center; gap: 10px; padding: 5px 4px;
            cursor: pointer; transition: opacity 0.3s; font-size: 12px; color: #94a3b8;
        }
        .legend-item:hover { color: #e2e8f0; }
        .legend-item.dimmed { opacity: 0.15; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
        .legend-count { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: #475569; margin-left: auto; }

        #controls {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 6px; z-index: 50;
        }
        #controls button {
            background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(255,255,255,0.08);
            color: #94a3b8; padding: 8px 16px; border-radius: 8px;
            font-family: 'JetBrains Mono', monospace; font-size: 11px;
            cursor: pointer; transition: all 0.2s; backdrop-filter: blur(10px);
        }
        #controls button:hover { background: rgba(30, 41, 59, 0.9); color: #e2e8f0; border-color: rgba(255,255,255,0.15); }
        #controls button.active { border-color: #fbbf24; color: #fbbf24; }

        #zoom-label {
            position: fixed; bottom: 60px; right: 20px;
            font-family: 'JetBrains Mono', monospace; font-size: 10px; color: #1e293b; z-index: 50;
        }
        #legend, #controls { transition: opacity 0.3s ease; }
    </style>
</head>
<body>

<div id="header">
    <h1><span>Factoría</span> Estudio</h1>
    <div class="sub" id="headerSub">network graph · 37 cursos · 9 áreas · scroll zoom · doble-click categoría para explorar</div>
</div>

<div id="tooltip">
    <div class="cat"></div>
    <div class="title"></div>
    <div class="desc"></div>
    <div class="badge"></div>
</div>

<div id="legend"></div>

<div id="controls">
    <button onclick="resetView()">Reset</button>
    <button onclick="togglePhysics()" id="btnPhysics" class="active">Física</button>
    <button onclick="startTour()" id="btnTour">Tour</button>
    <button onclick="shuffle()">Shuffle</button>
</div>

<div id="zoom-label"></div>

<canvas id="canvas"></canvas>

<script>
// ══════════════════════════════════════════════════
//  DATA
// ══════════════════════════════════════════════════
const CATEGORIES = {
    robotica:       { name: 'Robótica',        color: '#22c55e', accent2: '#16a34a' },
    hacking:        { name: 'Hacking Ético',   color: '#ef4444', accent2: '#dc2626' },
    cine:           { name: 'Cine',            color: '#a855f7', accent2: '#9333ea' },
    danza:          { name: 'Danza',           color: '#ec4899', accent2: '#db2777' },
    plastica:       { name: 'Plástica',        color: '#f97316', accent2: '#ea580c' },
    emprendimiento: { name: 'Emprendimiento',  color: '#eab308', accent2: '#ca8a04' },
    teatro:         { name: 'Teatro',          color: '#06b6d4', accent2: '#0891b2' },
    musica:         { name: 'Música',          color: '#d946ef', accent2: '#c026d3' },
    otras:          { name: 'Otras Artes',     color: '#8b5cf6', accent2: '#7c3aed' }
};

const COURSES = [
    { id: 'rob-67',  cat: 'robotica',       name: 'Robótica 6-7',      desc: 'Introducción a la robótica para los más pequeños con kits educativos' },
    { id: 'rob-89',  cat: 'robotica',       name: 'Robótica 8-9',      desc: 'Programación de robots con bloques y sensores básicos' },
    { id: 'rob-10',  cat: 'robotica',       name: 'Robótica 10+',      desc: 'Electrónica, programación y diseño 3D intermedio' },
    { id: 'rob-12',  cat: 'robotica',       name: 'Robótica 12+',      desc: 'Proyectos avanzados con Arduino, sensores y competición' },
    { id: 'hack-1',  cat: 'hacking',        name: 'Raspberry Pi',      desc: 'Hardware hacking y proyectos maker con Raspberry Pi' },
    { id: 'hack-2',  cat: 'hacking',        name: 'Laptop Hacking',    desc: 'Seguridad informática, pentesting y criptografía básica' },
    { id: 'hack-3',  cat: 'hacking',        name: 'Servidores',        desc: 'Administración de servidores, redes y seguridad' },
    { id: 'hack-4',  cat: 'hacking',        name: 'Drones & IoT',     desc: 'Hacking de dispositivos IoT, drones y comunicaciones' },
    { id: 'cine-1',  cat: 'cine',           name: 'Rodaje',            desc: 'Dirección de cámara, planos, iluminación y rodaje' },
    { id: 'cine-2',  cat: 'cine',           name: 'Guión & Storyboard',desc: 'Escritura de guión, narrativa visual y storyboard' },
    { id: 'cine-3',  cat: 'cine',           name: 'Edición & Montaje', desc: 'Postproducción digital, montaje y efectos visuales' },
    { id: 'cine-4',  cat: 'cine',           name: 'Sonido & Efectos',  desc: 'Diseño de sonido, foley y mezcla de audio' },
    { id: 'dan-1',   cat: 'danza',          name: 'Clásica',           desc: 'Ballet clásico y técnica académica' },
    { id: 'dan-2',   cat: 'danza',          name: 'Moderno',           desc: 'Danza contemporánea y expresión corporal' },
    { id: 'dan-3',   cat: 'danza',          name: 'Flamenco',          desc: 'Flamenco y danza española tradicional' },
    { id: 'dan-4',   cat: 'danza',          name: 'Ballet Adultos',    desc: 'Ballet para todas las edades, iniciación y perfeccionamiento' },
    { id: 'plas-1',  cat: 'plastica',       name: 'Dibujo & Boceto',   desc: 'Técnicas de dibujo, perspectiva y bocetaje' },
    { id: 'plas-2',  cat: 'plastica',       name: 'Pintura & Color',   desc: 'Composición, teoría del color y técnicas pictóricas' },
    { id: 'plas-3',  cat: 'plastica',       name: 'Escultura',         desc: 'Modelado, escultura y trabajo tridimensional' },
    { id: 'plas-4',  cat: 'plastica',       name: 'Atrezo & Decoración', desc: 'Creación de atrezo, escenografía y decoración' },
    { id: 'empr-1',  cat: 'emprendimiento', name: 'Miniempresas',      desc: 'Creación y gestión de miniempresas juveniles' },
    { id: 'empr-2',  cat: 'emprendimiento', name: 'Innovación',        desc: 'Design thinking, creatividad e innovación aplicada' },
    { id: 'empr-3',  cat: 'emprendimiento', name: 'Proyecto Final',    desc: 'Desarrollo y pitch de proyecto empresarial real' },
    { id: 'teat-1',  cat: 'teatro',         name: 'Teatro Musical',    desc: 'Canto, baile e interpretación integrados' },
    { id: 'teat-2',  cat: 'teatro',         name: 'Teatro I-III',      desc: 'Interpretación y artes escénicas por niveles' },
    { id: 'mus-1',   cat: 'musica',         name: 'Piano',             desc: 'Piano clásico y moderno, lectura e interpretación' },
    { id: 'mus-2',   cat: 'musica',         name: 'Guitarra',          desc: 'Guitarra clásica, acústica y eléctrica' },
    { id: 'mus-3',   cat: 'musica',         name: 'Violín',            desc: 'Técnica de violín, repertorio clásico y moderno' },
    { id: 'mus-4',   cat: 'musica',         name: 'Canto',             desc: 'Técnica vocal, respiración y proyección' },
    { id: 'mus-5',   cat: 'musica',         name: 'Batería & Percusión', desc: 'Ritmo, coordinación y técnicas de percusión' },
    { id: 'mus-6',   cat: 'musica',         name: 'Lenguaje Musical',  desc: 'Solfeo, armonía y teoría musical' },
    { id: 'mus-7',   cat: 'musica',         name: 'Combo & Banda',     desc: 'Práctica en grupo, ensamble y repertorio' },
    { id: 'mus-8',   cat: 'musica',         name: 'Iniciación Musical',desc: 'Primeros pasos en la música para los más pequeños' },
    { id: 'foto',    cat: 'otras',          name: 'Fotografía',        desc: 'Técnica fotográfica, composición y revelado digital' },
    { id: 'orat',    cat: 'otras',          name: 'Oratoria',          desc: 'Comunicación, debate y expresión oral' },
    { id: 'magia',   cat: 'otras',          name: 'Magia',             desc: 'Ilusionismo, prestidigitación y artes mágicas' },
    { id: 'confec',  cat: 'otras',          name: 'Confección',        desc: 'Diseño textil, patronaje y costura creativa' }
];

const CROSS_LINKS = [
    ['teat-1', 'dan-2',  'Artes escénicas'],
    ['teat-1', 'cine-4', 'Sonido y música'],
    ['foto',   'cine-1', 'Imagen y cámara'],
    ['plas-4', 'teat-2', 'Escenografía'],
    ['orat',   'teat-2', 'Expresión oral'],
    ['hack-4', 'rob-12', 'Hardware avanzado'],
    ['empr-2', 'hack-2', 'Innovación tech'],
    ['plas-1', 'cine-2', 'Storyboard'],
    ['confec', 'plas-4', 'Diseño y creación'],
    ['magia',  'teat-1', 'Performance'],
    ['dan-1',  'dan-4',  'Técnica ballet'],
    ['cine-3', 'cine-4', 'Postproducción'],
    ['mus-4',  'teat-1', 'Canto escénico'],
    ['mus-7',  'cine-4', 'Producción sonora'],
    ['mus-6',  'dan-1',  'Ritmo y compás'],
    ['mus-5',  'mus-7',  'Ensemble'],
    ['mus-1',  'mus-6',  'Armonía']
];

// ══════════════════════════════════════════════════
//  CANVAS & DPR
// ══════════════════════════════════════════════════
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H, dpr;

function resize() {
    dpr = window.devicePixelRatio || 1;
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
window.addEventListener('resize', resize);
resize();

// ══════════════════════════════════════════════════
//  GRAPH STRUCTURE
// ══════════════════════════════════════════════════
let nodes = [];
let edges = [];
let crossEdges = [];
const nodeMap = {};

// Create category hub nodes
const catKeys = Object.keys(CATEGORIES);
catKeys.forEach((key, i) => {
    const angle = (i / catKeys.length) * Math.PI * 2 - Math.PI / 2;
    const r = Math.min(W, H) * 0.42;
    const node = {
        id: 'cat-' + key,
        type: 'category',
        catKey: key,
        label: CATEGORIES[key].name,
        color: CATEGORIES[key].color,
        x: Math.cos(angle) * r,
        y: Math.sin(angle) * r,
        vx: 0, vy: 0, fx: 0, fy: 0,
        radius: 28,
        phase: Math.random() * Math.PI * 2,
        pinned: false
    };
    initDrift(node);
    nodes.push(node);
    nodeMap[node.id] = node;
});

// Create course nodes
COURSES.forEach((c, i) => {
    const hub = nodeMap['cat-' + c.cat];
    const spread = 140 + Math.random() * 60;
    const a = Math.random() * Math.PI * 2;
    const node = {
        id: c.id,
        type: 'course',
        catKey: c.cat,
        label: c.name,
        desc: c.desc,
        color: CATEGORIES[c.cat].color,
        x: hub.x + Math.cos(a) * spread,
        y: hub.y + Math.sin(a) * spread,
        vx: 0, vy: 0, fx: 0, fy: 0,
        radius: 14,
        phase: Math.random() * Math.PI * 2,
        pinned: false
    };
    initDrift(node);
    nodes.push(node);
    nodeMap[node.id] = node;
    edges.push({ source: hub, target: node, color: hub.color });
});

// Cross-category links
CROSS_LINKS.forEach(([a, b, label]) => {
    const na = nodeMap[a], nb = nodeMap[b];
    if (na && nb) crossEdges.push({ source: na, target: nb, label, color: '#334155' });
});

// ══════════════════════════════════════════════════
//  CAMERA
// ══════════════════════════════════════════════════
let cam = { x: 0, y: 0, zoom: 1 };
let targetCam = { x: 0, y: 0, zoom: 1 };

function worldToScreen(wx, wy) {
    return {
        x: (wx - cam.x) * cam.zoom + W / 2,
        y: (wy - cam.y) * cam.zoom + H / 2
    };
}
function screenToWorld(sx, sy) {
    return {
        x: (sx - W / 2) / cam.zoom + cam.x,
        y: (sy - H / 2) / cam.zoom + cam.y
    };
}

function resetView() {
    targetCam = { x: 0, y: 0, zoom: Math.min(W, H) / 1400 };
}
resetView();
cam = { ...targetCam };

// ══════════════════════════════════════════════════
//  PHYSICS
// ══════════════════════════════════════════════════
let physicsOn = true;

// Soft-body sphere physics
const COLLISION_PAD = 4.0;     // multiplier on radii sum for personal space
const COLLISION_K   = 0.8;     // how firmly spheres push apart
const CHARGE        = -120;    // gentle long-range repulsion
const LINK_DIST     = 180;
const LINK_K        = 0.008;
const CROSS_DIST    = 400;
const CROSS_K       = 0.0015;
const GRAVITY       = 0.0006;
const DAMPING       = 0.55;
const MAX_VEL       = 1.8;
const DEAD_ZONE     = 0.04;    // kill micro-vibrations below this speed

// Each node gets unique drift parameters for star-like floating
function initDrift(nd) {
    nd.driftAx = (Math.random() - 0.5) * 0.25;
    nd.driftAy = (Math.random() - 0.5) * 0.25;
    nd.driftFx = 0.08 + Math.random() * 0.08;
    nd.driftFy = 0.06 + Math.random() * 0.07;
    nd.driftPx = Math.random() * Math.PI * 2;
    nd.driftPy = Math.random() * Math.PI * 2;
}

function simulate() {
    const n = nodes.length;

    if (!physicsOn) {
        // Gentle star-like floating drift
        nodes.forEach(nd => {
            if (nd.pinned || nd === dragNode) return;
            nd.x += Math.sin(time * nd.driftFx + nd.driftPx) * nd.driftAx;
            nd.y += Math.cos(time * nd.driftFy + nd.driftPy) * nd.driftAy;
        });
        return;
    }

    // Reset forces
    for (let i = 0; i < n; i++) { nodes[i].fx = 0; nodes[i].fy = 0; }

    // Sphere collision + long-range repulsion (all pairs)
    for (let i = 0; i < n; i++) {
        const a = nodes[i];
        for (let j = i + 1; j < n; j++) {
            const b = nodes[j];
            let dx = b.x - a.x, dy = b.y - a.y;
            let d2 = dx * dx + dy * dy;
            if (d2 < 0.1) { dx = (Math.random() - 0.5) * 2; dy = (Math.random() - 0.5) * 2; d2 = dx*dx + dy*dy; }
            const d = Math.sqrt(d2);

            // Soft sphere collision — the core fix
            const minDist = (a.radius + b.radius) * COLLISION_PAD;
            let force = 0;
            if (d < minDist) {
                // Strong proportional push when overlapping
                force = (minDist - d) * COLLISION_K;
            }

            // Gentle long-range Coulomb repulsion (capped to avoid explosions)
            force += CHARGE / Math.max(d2, 400);

            const fx = (dx / d) * force;
            const fy = (dy / d) * force;
            a.fx -= fx; a.fy -= fy;
            b.fx += fx; b.fy += fy;
        }
    }

    // Link springs — only attract beyond natural length, very gentle push when close
    edges.forEach(e => {
        let dx = e.target.x - e.source.x, dy = e.target.y - e.source.y;
        const d = Math.sqrt(dx * dx + dy * dy) || 1;
        const gap = d - LINK_DIST;
        const k = gap > 0 ? LINK_K : LINK_K * 0.15;
        const force = gap * k;
        const fx = dx / d * force, fy = dy / d * force;
        e.source.fx += fx; e.source.fy += fy;
        e.target.fx -= fx; e.target.fy -= fy;
    });

    // Cross-link springs (very soft)
    crossEdges.forEach(e => {
        let dx = e.target.x - e.source.x, dy = e.target.y - e.source.y;
        const d = Math.sqrt(dx * dx + dy * dy) || 1;
        const gap = d - CROSS_DIST;
        const k = gap > 0 ? CROSS_K : CROSS_K * 0.1;
        const force = gap * k;
        const fx = dx / d * force, fy = dy / d * force;
        e.source.fx += fx; e.source.fy += fy;
        e.target.fx -= fx; e.target.fy -= fy;
    });

    // Very gentle center gravity
    nodes.forEach(nd => {
        nd.fx -= nd.x * GRAVITY;
        nd.fy -= nd.y * GRAVITY;
    });

    // Integrate with velocity cap + dead zone (kills vibration)
    nodes.forEach(nd => {
        if (nd.pinned || nd === dragNode) return;
        nd.vx = (nd.vx + nd.fx) * DAMPING;
        nd.vy = (nd.vy + nd.fy) * DAMPING;
        const speed = Math.sqrt(nd.vx * nd.vx + nd.vy * nd.vy);
        if (speed < DEAD_ZONE) { nd.vx = 0; nd.vy = 0; return; }
        if (speed > MAX_VEL) { nd.vx *= MAX_VEL / speed; nd.vy *= MAX_VEL / speed; }
        nd.x += nd.vx;
        nd.y += nd.vy;
    });
}

// ══════════════════════════════════════════════════
//  UNIVERSE BACKGROUND
// ══════════════════════════════════════════════════

// Deep star field — 3 layers with parallax
const starLayers = [];
const STAR_COUNTS = [400, 200, 60];   // far, mid, near
const STAR_SIZES  = [0.6, 1.2, 2.2];
const STAR_DEPTHS = [0.15, 0.4, 0.85]; // parallax factor (0=fixed, 1=full camera)
const STAR_SPREAD = 3500;

for (let layer = 0; layer < 3; layer++) {
    const arr = [];
    for (let i = 0; i < STAR_COUNTS[layer]; i++) {
        // Star color temperature (blue-white-yellow-orange)
        const temp = Math.random();
        let sr, sg, sb;
        if (temp < 0.15)      { sr = 155; sg = 176; sb = 255; } // blue-white (hot)
        else if (temp < 0.4)  { sr = 200; sg = 210; sb = 255; } // white-blue
        else if (temp < 0.75) { sr = 255; sg = 250; sb = 240; } // white
        else if (temp < 0.9)  { sr = 255; sg = 220; sb = 180; } // warm yellow
        else                  { sr = 255; sg = 190; sb = 140; } // orange giant
        arr.push({
            x: (Math.random() - 0.5) * STAR_SPREAD,
            y: (Math.random() - 0.5) * STAR_SPREAD,
            r: STAR_SIZES[layer] * (0.6 + Math.random() * 0.8),
            alpha: (0.15 + Math.random() * 0.6) * (layer === 2 ? 1 : 0.7),
            phase: Math.random() * Math.PI * 2,
            twinkleSpeed: 0.3 + Math.random() * 0.7,
            color: `${sr},${sg},${sb}`,
            hasCross: layer === 2 && Math.random() < 0.3, // bright stars get cross flare
        });
    }
    starLayers.push(arr);
}

// Nebula clouds — pre-computed positions (world space for parallax)
const nebulaeClouds = [
    { x: -600,  y: -400,  rx: 500, ry: 350, angle: 0.3,   c1: [80,20,120],  c2: [30,10,80],   a: 0.035 },
    { x:  700,  y:  300,  rx: 400, ry: 500, angle: -0.5,  c1: [20,60,120],  c2: [10,30,90],   a: 0.03  },
    { x:  100,  y: -700,  rx: 600, ry: 250, angle: 0.8,   c1: [120,30,50],  c2: [80,10,30],   a: 0.025 },
    { x: -500,  y:  600,  rx: 350, ry: 400, angle: -0.2,  c1: [20,80,80],   c2: [10,50,60],   a: 0.03  },
    { x:  500,  y: -500,  rx: 450, ry: 300, angle: 1.2,   c1: [100,40,100], c2: [50,15,70],   a: 0.02  },
    { x: -200,  y:  200,  rx: 700, ry: 500, angle: 0.1,   c1: [40,20,80],   c2: [15,8,50],    a: 0.018 },
    // Milky way band (very wide, subtle)
    { x:  0,    y:  0,    rx: 1600,ry: 200, angle: 0.6,   c1: [50,45,70],   c2: [25,22,40],   a: 0.04  },
];

// Cosmic dust particles (tiny, dense, in clusters)
const cosmicDust = [];
for (let i = 0; i < 300; i++) {
    // Cluster around nebula regions
    const cluster = Math.floor(Math.random() * nebulaeClouds.length);
    const nc = nebulaeClouds[cluster];
    cosmicDust.push({
        x: nc.x + (Math.random() - 0.5) * nc.rx * 2.5,
        y: nc.y + (Math.random() - 0.5) * nc.ry * 2.5,
        r: 0.3 + Math.random() * 0.5,
        alpha: 0.05 + Math.random() * 0.15,
        phase: Math.random() * Math.PI * 2,
        color: `${nc.c1[0]},${nc.c1[1]},${nc.c1[2]}`
    });
}

// Pre-render static background to offscreen canvas for performance
let bgCanvas = null;
let bgNeedsRedraw = true;

function renderStaticBg() {
    bgCanvas = document.createElement('canvas');
    bgCanvas.width = W * dpr;
    bgCanvas.height = H * dpr;
    const bg = bgCanvas.getContext('2d');
    bg.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Deep space base — radial gradient from dark blue center to black edges
    const base = bg.createRadialGradient(W/2, H/2, 0, W/2, H/2, W * 0.8);
    base.addColorStop(0, '#0a0e1a');
    base.addColorStop(0.5, '#060a14');
    base.addColorStop(1, '#020408');
    bg.fillStyle = base;
    bg.fillRect(0, 0, W, H);

    // Subtle large-scale color variation (galactic background)
    const zones = [
        { x: W*0.2, y: H*0.3, r: W*0.5, c: '30,20,60' },
        { x: W*0.8, y: H*0.6, r: W*0.4, c: '15,30,50' },
        { x: W*0.5, y: H*0.1, r: W*0.35, c: '40,15,25' },
    ];
    zones.forEach(z => {
        const g = bg.createRadialGradient(z.x, z.y, 0, z.x, z.y, z.r);
        g.addColorStop(0, `rgba(${z.c},0.06)`);
        g.addColorStop(1, 'transparent');
        bg.fillStyle = g;
        bg.fillRect(0, 0, W, H);
    });

    bgNeedsRedraw = false;
    return bgCanvas;
}

window.addEventListener('resize', () => { bgNeedsRedraw = true; });

// ══════════════════════════════════════════════════
//  RENDERING
// ══════════════════════════════════════════════════
let time = 0;
let hoveredNode = null;
let highlightCat = null;

// ══════════════════════════════════════════════════
//  INTERNAL SPHERE PATTERNS (per category)
// ══════════════════════════════════════════════════
function drawPattern(key, ctx, x, y, r, t, ph) {
    switch (key) {
        case 'robotica':       patGears(ctx,x,y,r,t,ph); break;
        case 'hacking':        patMatrix(ctx,x,y,r,t,ph); break;
        case 'cine':           patFilm(ctx,x,y,r,t,ph); break;
        case 'danza':          patRibbons(ctx,x,y,r,t,ph); break;
        case 'plastica':       patPaint(ctx,x,y,r,t,ph); break;
        case 'emprendimiento': patChart(ctx,x,y,r,t,ph); break;
        case 'teatro':         patSpotlight(ctx,x,y,r,t,ph); break;
        case 'musica':         patWaves(ctx,x,y,r,t,ph); break;
        case 'otras':          patKaleidoscope(ctx,x,y,r,t,ph); break;
    }
}

// 1. Robótica — Meshing gears
function patGears(ctx, x, y, r, t, ph) {
    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = Math.max(0.8, r * 0.035);
    const gears = [
        { cx: -0.22, cy: -0.1, gr: 0.38, teeth: 8, dir: 1 },
        { cx:  0.22, cy:  0.18, gr: 0.28, teeth: 6, dir: -1.33 }
    ];
    gears.forEach(g => {
        const gx = x + g.cx * r, gy = y + g.cy * r, gr = g.gr * r;
        const rot = t * 0.4 * g.dir + ph;
        ctx.beginPath();
        const steps = g.teeth * 2;
        for (let i = 0; i <= steps; i++) {
            const a = rot + (i / steps) * Math.PI * 2;
            const rad = i % 2 === 0 ? gr : gr * 0.72;
            const px = gx + Math.cos(a) * rad, py = gy + Math.sin(a) * rad;
            i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(gx, gy, gr * 0.18, 0, Math.PI * 2);
        ctx.stroke();
    });
    // Axle dots
    gears.forEach(g => {
        ctx.beginPath();
        ctx.arc(x + g.cx * r, y + g.cy * r, r * 0.04, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fill();
    });
}

// 2. Hacking — Matrix binary rain
function patMatrix(ctx, x, y, r, t, ph) {
    const fontSize = Math.max(5, r * 0.14);
    ctx.font = `${fontSize}px "JetBrains Mono"`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const cols = 6, rows = 7;
    const cw = (r * 1.5) / cols, rh = (r * 1.6) / rows;
    for (let c = 0; c < cols; c++) {
        const cx = x - r * 0.75 + cw * (c + 0.5);
        const speed = 0.6 + (c * 0.13 + ph * 0.5) % 0.4;
        const yOff = (t * speed * rh * 1.5) % (rh * 2);
        for (let row = 0; row < rows; row++) {
            const cy = y - r * 0.75 + rh * row + yOff;
            const seed = Math.floor(t * speed * 1.5 + c * 7.3 + row * 3.1 + ph * 11);
            const chars = '01アイウカキ';
            const ch = chars[Math.abs(seed) % chars.length];
            const fade = 1 - Math.abs((row + 0.5) / rows - 0.5) * 2;
            ctx.globalAlpha = fade * 0.45;
            ctx.fillStyle = row === 0 ? 'rgba(180,255,180,0.9)' : 'rgba(255,255,255,0.6)';
            ctx.fillText(ch, cx, cy);
        }
    }
}

// 3. Cine — Film strip scrolling
function patFilm(ctx, x, y, r, t, ph) {
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = Math.max(0.5, r * 0.025);
    const stripH = r * 0.55;
    const frameW = r * 0.45;
    const scroll = (t * 0.3 + ph) * r;
    const sy = y - stripH / 2;
    // Film borders
    ctx.strokeRect(x - r * 0.85, sy, r * 1.7, stripH);
    // Sprocket holes
    for (let i = -3; i < 4; i++) {
        const hx = x + i * frameW - (scroll % frameW);
        const holeSize = r * 0.05;
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(hx - holeSize, sy + r * 0.03, holeSize * 2, holeSize * 1.5);
        ctx.fillRect(hx - holeSize, sy + stripH - r * 0.03 - holeSize * 1.5, holeSize * 2, holeSize * 1.5);
    }
    // Frames
    for (let i = -2; i < 3; i++) {
        const fx = x + i * frameW - (scroll % frameW);
        ctx.strokeRect(fx - frameW * 0.4, sy + stripH * 0.18, frameW * 0.8, stripH * 0.64);
        // "Scene" — simple abstract shapes
        const seed = Math.floor(i + scroll / frameW + ph * 10);
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        if (seed % 3 === 0) {
            ctx.beginPath();
            ctx.arc(fx, y, r * 0.08, 0, Math.PI * 2);
            ctx.fill();
        } else if (seed % 3 === 1) {
            ctx.fillRect(fx - r * 0.06, y - r * 0.1, r * 0.12, r * 0.2);
        }
        ctx.globalAlpha = 1;
    }
}

// 4. Danza — Flowing silk ribbons
function patRibbons(ctx, x, y, r, t, ph) {
    ctx.lineWidth = Math.max(1, r * 0.04);
    ctx.lineCap = 'round';
    const ribbons = [
        { freq: 2.5, amp: 0.35, speed: 0.7, yOff: -0.2, alpha: 0.45 },
        { freq: 3.2, amp: 0.25, speed: -0.5, yOff: 0.05, alpha: 0.35 },
        { freq: 1.8, amp: 0.4, speed: 0.9, yOff: 0.25, alpha: 0.3 }
    ];
    ribbons.forEach(rb => {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,255,255,${rb.alpha})`;
        for (let i = 0; i <= 30; i++) {
            const pct = i / 30;
            const px = x - r * 0.8 + pct * r * 1.6;
            const wave = Math.sin(pct * rb.freq * Math.PI + t * rb.speed + ph) * rb.amp * r;
            const py = y + rb.yOff * r + wave;
            i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.stroke();
    });
}

// 5. Plástica — Abstract paint splatters & circles
function patPaint(ctx, x, y, r, t, ph) {
    const spots = [
        { dx: -0.3, dy: -0.2, sr: 0.22, hue: 0 },
        { dx:  0.2, dy: -0.15,sr: 0.18, hue: 60 },
        { dx: -0.1, dy:  0.25,sr: 0.2,  hue: 200 },
        { dx:  0.3, dy:  0.2, sr: 0.15, hue: 300 },
        { dx:  0.0, dy:  0.0, sr: 0.16, hue: 120 }
    ];
    spots.forEach((s, i) => {
        const pulse = 1 + Math.sin(t * 0.5 + ph + i * 1.3) * 0.15;
        const sx = x + s.dx * r, sy = y + s.dy * r, sr = s.sr * r * pulse;
        const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, sr);
        const hueShift = (s.hue + t * 10 + ph * 50) % 360;
        grad.addColorStop(0, `hsla(${hueShift},70%,70%,0.3)`);
        grad.addColorStop(0.6, `hsla(${hueShift},60%,50%,0.1)`);
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(sx, sy, sr, 0, Math.PI * 2);
        ctx.fill();
    });
    // Brush stroke
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = Math.max(2, r * 0.08);
    ctx.lineCap = 'round';
    ctx.moveTo(x - r * 0.5, y + r * 0.1);
    ctx.quadraticCurveTo(x, y - r * 0.3, x + r * 0.5, y + r * 0.05);
    ctx.stroke();
}

// 6. Emprendimiento — Growing bar chart
function patChart(ctx, x, y, r, t, ph) {
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = Math.max(0.5, r * 0.02);
    const bars = 5;
    const bw = (r * 1.2) / (bars * 1.8);
    const baseY = y + r * 0.4;
    // Axis
    ctx.beginPath();
    ctx.moveTo(x - r * 0.6, baseY);
    ctx.lineTo(x + r * 0.6, baseY);
    ctx.moveTo(x - r * 0.6, baseY);
    ctx.lineTo(x - r * 0.6, y - r * 0.5);
    ctx.stroke();
    // Bars
    for (let i = 0; i < bars; i++) {
        const bx = x - r * 0.5 + i * (r * 1.1) / bars;
        const targetH = (0.3 + ((i * 37 + Math.floor(ph * 7)) % 10) * 0.065) * r;
        const animH = targetH * Math.min(1, 0.5 + 0.5 * Math.sin(t * 0.4 + i * 0.8 + ph));
        ctx.fillStyle = `rgba(255,255,255,${0.2 + i * 0.05})`;
        ctx.fillRect(bx, baseY - animH, bw, animH);
    }
    // Trend line
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = Math.max(0.8, r * 0.03);
    for (let i = 0; i < bars; i++) {
        const bx = x - r * 0.5 + i * (r * 1.1) / bars + bw / 2;
        const targetH = (0.3 + ((i * 37 + Math.floor(ph * 7)) % 10) * 0.065) * r;
        const h = targetH * Math.min(1, 0.5 + 0.5 * Math.sin(t * 0.4 + i * 0.8 + ph));
        i === 0 ? ctx.moveTo(bx, baseY - h) : ctx.lineTo(bx, baseY - h);
    }
    ctx.stroke();
}

// 7. Teatro — Spotlight beams on stage
function patSpotlight(ctx, x, y, r, t, ph) {
    // Stage floor
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = Math.max(0.5, r * 0.02);
    ctx.beginPath();
    ctx.moveTo(x - r * 0.8, y + r * 0.35);
    ctx.lineTo(x + r * 0.8, y + r * 0.35);
    ctx.stroke();
    // Spotlights from above
    const spots = [
        { sx: -0.25, angle: 0.15, w: 0.3 },
        { sx:  0.25, angle: -0.1, w: 0.25 },
        { sx:  0.0,  angle: 0.0,  w: 0.35 }
    ];
    spots.forEach((s, i) => {
        const pulse = 0.6 + 0.4 * Math.sin(t * 0.6 + ph + i * 2.1);
        const topX = x + s.sx * r;
        const topY = y - r * 0.6;
        const botL = topX - s.w * r + s.angle * r;
        const botR = topX + s.w * r + s.angle * r;
        const botY = y + r * 0.35;
        const grad = ctx.createLinearGradient(topX, topY, topX, botY);
        grad.addColorStop(0, `rgba(255,255,220,${0.25 * pulse})`);
        grad.addColorStop(1, `rgba(255,255,220,${0.03 * pulse})`);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(topX - r * 0.03, topY);
        ctx.lineTo(botL, botY);
        ctx.lineTo(botR, botY);
        ctx.lineTo(topX + r * 0.03, topY);
        ctx.closePath();
        ctx.fill();
    });
    // Spot sources
    spots.forEach(s => {
        ctx.beginPath();
        ctx.arc(x + s.sx * r, y - r * 0.6, r * 0.04, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,200,0.6)';
        ctx.fill();
    });
}

// 8. Música — Equalizer bars
function patWaves(ctx, x, y, r, t, ph) {
    const bars = 9;
    const bw = (r * 1.3) / (bars * 1.6);
    const gap = (r * 1.3) / bars;
    ctx.lineCap = 'round';
    for (let i = 0; i < bars; i++) {
        const bx = x - r * 0.65 + i * gap + gap * 0.3;
        const freq = 1.2 + i * 0.3;
        const h = (0.15 + Math.abs(Math.sin(t * freq * 0.5 + ph + i * 0.9)) * 0.55) * r;
        const grad = ctx.createLinearGradient(bx, y + r * 0.3, bx, y + r * 0.3 - h);
        grad.addColorStop(0, 'rgba(255,255,255,0.15)');
        grad.addColorStop(1, 'rgba(255,255,255,0.45)');
        ctx.fillStyle = grad;
        ctx.fillRect(bx, y + r * 0.3 - h, bw, h);
        // Peak dot
        ctx.beginPath();
        ctx.arc(bx + bw / 2, y + r * 0.3 - h - r * 0.03, r * 0.025, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fill();
    }
    // Waveform overlay
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = Math.max(0.5, r * 0.025);
    for (let i = 0; i <= 30; i++) {
        const pct = i / 30;
        const px = x - r * 0.7 + pct * r * 1.4;
        const py = y - r * 0.25 + Math.sin(pct * 6 + t * 1.2 + ph) * r * 0.12;
        i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.stroke();
}

// 9. Otras Artes — Kaleidoscope geometry
function patKaleidoscope(ctx, x, y, r, t, ph) {
    const segments = 6;
    const rot = t * 0.15 + ph;
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = Math.max(0.5, r * 0.025);
    // Rotating geometric layers
    for (let layer = 0; layer < 3; layer++) {
        const sides = segments - layer;
        const lr = r * (0.25 + layer * 0.2);
        const lRot = rot * (1 + layer * 0.4) * (layer % 2 === 0 ? 1 : -1);
        ctx.globalAlpha = 0.3 - layer * 0.07;
        ctx.beginPath();
        for (let i = 0; i <= sides; i++) {
            const a = lRot + (i / sides) * Math.PI * 2;
            const px = x + Math.cos(a) * lr;
            const py = y + Math.sin(a) * lr;
            i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.stroke();
        // Inner lines to center
        for (let i = 0; i < sides; i++) {
            const a = lRot + (i / sides) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(a) * lr, y + Math.sin(a) * lr);
            ctx.stroke();
        }
    }
    // Center gem
    ctx.globalAlpha = 0.4;
    const gemGrad = ctx.createRadialGradient(x, y, 0, x, y, r * 0.12);
    gemGrad.addColorStop(0, 'rgba(255,255,255,0.5)');
    gemGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = gemGrad;
    ctx.beginPath();
    ctx.arc(x, y, r * 0.12, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
}

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function render() {
    ctx.save();

    // ── Static deep space background ──
    if (bgNeedsRedraw || !bgCanvas) renderStaticBg();
    ctx.drawImage(bgCanvas, 0, 0, W, H);

    // ── Nebula clouds (world space with parallax) ──
    nebulaeClouds.forEach(nc => {
        const parallax = 0.3;
        const sx = (nc.x - cam.x * parallax) * cam.zoom + W / 2;
        const sy = (nc.y - cam.y * parallax) * cam.zoom + H / 2;
        const srx = nc.rx * cam.zoom;
        const sry = nc.ry * cam.zoom;

        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(nc.angle);

        // Multi-layer nebula for depth
        for (let layer = 0; layer < 3; layer++) {
            const scale = 1 + layer * 0.3;
            const alpha = nc.a * (1 - layer * 0.3);
            const c = layer < 2 ? nc.c1 : nc.c2;
            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, Math.max(srx, sry) * scale);
            grad.addColorStop(0, `rgba(${c[0]},${c[1]},${c[2]},${alpha})`);
            grad.addColorStop(0.3, `rgba(${c[0]},${c[1]},${c[2]},${alpha * 0.6})`);
            grad.addColorStop(0.7, `rgba(${c[0]},${c[1]},${c[2]},${alpha * 0.15})`);
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(0, 0, srx * scale, sry * scale, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    });

    // ── Cosmic dust ──
    cosmicDust.forEach(d => {
        const parallax = 0.25;
        const sx = (d.x - cam.x * parallax) * cam.zoom + W / 2;
        const sy = (d.y - cam.y * parallax) * cam.zoom + H / 2;
        if (sx < -20 || sx > W + 20 || sy < -20 || sy > H + 20) return;
        const twk = 0.5 + 0.5 * Math.sin(time * 0.4 + d.phase);
        ctx.globalAlpha = d.alpha * twk;
        ctx.fillStyle = `rgb(${d.color})`;
        ctx.beginPath();
        ctx.arc(sx, sy, d.r * cam.zoom, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;

    // ── Star layers with parallax ──
    starLayers.forEach((layer, li) => {
        const depth = STAR_DEPTHS[li];
        layer.forEach(s => {
            const sx = (s.x - cam.x * depth) * cam.zoom + W / 2;
            const sy = (s.y - cam.y * depth) * cam.zoom + H / 2;
            if (sx < -10 || sx > W + 10 || sy < -10 || sy > H + 10) return;

            const twinkle = 0.5 + 0.5 * Math.sin(time * s.twinkleSpeed + s.phase);
            const a = s.alpha * twinkle;
            const sr = s.r * cam.zoom;

            // Star glow
            if (sr > 1) {
                const glowGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, sr * 4);
                glowGrad.addColorStop(0, `rgba(${s.color},${a * 0.3})`);
                glowGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(sx, sy, sr * 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // Star core
            ctx.globalAlpha = a;
            ctx.fillStyle = `rgb(${s.color})`;
            ctx.beginPath();
            ctx.arc(sx, sy, sr, 0, Math.PI * 2);
            ctx.fill();

            // Cross flare for bright stars
            if (s.hasCross && a > 0.4) {
                ctx.globalAlpha = a * 0.3;
                ctx.strokeStyle = `rgb(${s.color})`;
                ctx.lineWidth = 0.5;
                const len = sr * 6;
                ctx.beginPath();
                ctx.moveTo(sx - len, sy); ctx.lineTo(sx + len, sy);
                ctx.moveTo(sx, sy - len); ctx.lineTo(sx, sy + len);
                ctx.stroke();
            }
        });
    });
    ctx.globalAlpha = 1;

    // ── Vignette (deep space edges) ──
    const vig = ctx.createRadialGradient(W / 2, H / 2, W * 0.2, W / 2, H / 2, W * 0.8);
    vig.addColorStop(0, 'transparent');
    vig.addColorStop(1, 'rgba(2,4,8,0.55)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, W, H);

    // Determine active state
    const activeSet = new Set();
    if (hoveredNode) {
        activeSet.add(hoveredNode.id);
        edges.forEach(e => {
            if (e.source === hoveredNode || e.target === hoveredNode) {
                activeSet.add(e.source.id);
                activeSet.add(e.target.id);
            }
        });
        crossEdges.forEach(e => {
            if (e.source === hoveredNode || e.target === hoveredNode) {
                activeSet.add(e.source.id);
                activeSet.add(e.target.id);
            }
        });
    }

    // ── Cross edges (behind) ──
    crossEdges.forEach(e => {
        const s = worldToScreen(e.source.x, e.source.y);
        const t = worldToScreen(e.target.x, e.target.y);
        const isActive = hoveredNode && (e.source === hoveredNode || e.target === hoveredNode);
        const dimmed = highlightCat && e.source.catKey !== highlightCat && e.target.catKey !== highlightCat;

        ctx.beginPath();
        // Curved cross-links
        const mx = (s.x + t.x) / 2, my = (s.y + t.y) / 2;
        const dx = t.x - s.x, dy = t.y - s.y;
        const cx = mx - dy * 0.15, cy = my + dx * 0.15;
        ctx.moveTo(s.x, s.y);
        ctx.quadraticCurveTo(cx, cy, t.x, t.y);

        ctx.strokeStyle = isActive ? 'rgba(148,163,184,0.5)' : 'rgba(51,65,85,0.15)';
        ctx.lineWidth = isActive ? 1.5 : 0.8;
        if (!isActive) ctx.setLineDash([4, 6]);
        if (dimmed) ctx.globalAlpha = 0.05;
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;

        // Cross-link label on hover
        if (isActive && e.label) {
            const lx = (s.x + t.x) / 2 - (dy * 0.075);
            const ly = (s.y + t.y) / 2 + (dx * 0.075);
            ctx.font = '500 10px "JetBrains Mono"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(148,163,184,0.7)';
            ctx.fillText(e.label, lx, ly);
        }
    });

    // ── Main edges ──
    edges.forEach(e => {
        const s = worldToScreen(e.source.x, e.source.y);
        const t = worldToScreen(e.target.x, e.target.y);
        const isActive = hoveredNode && (e.source === hoveredNode || e.target === hoveredNode);
        const dimmed = highlightCat && e.target.catKey !== highlightCat;
        const catDimmed = hoveredNode && !activeSet.has(e.source.id) && !activeSet.has(e.target.id);
        const [r, g, b] = hexToRgb(e.color);

        let alpha = isActive ? 0.6 : 0.12;
        if (catDimmed) alpha = 0.04;
        if (dimmed) alpha = 0.03;

        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(t.x, t.y);
        ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
        ctx.lineWidth = isActive ? 2 : 1;
        ctx.stroke();

        // Edge particles (flowing dots)
        if (!dimmed && !catDimmed) {
            for (let p = 0; p < 2; p++) {
                const tt = ((time * 0.12 + p * 0.5 + e.target.phase * 0.1) % 1);
                const px = s.x + (t.x - s.x) * tt;
                const py = s.y + (t.y - s.y) * tt;
                const pAlpha = isActive ? 0.8 : 0.2;
                const pSize = isActive ? 2.5 : 1.5;
                ctx.beginPath();
                ctx.arc(px, py, pSize * cam.zoom, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${r},${g},${b},${pAlpha * (0.5 + 0.5 * Math.sin(tt * Math.PI))})`;
                ctx.fill();
            }
        }
    });

    // ── Pulse waves (behind nodes) ──
    nodes.forEach(nd => {
        const sp = worldToScreen(nd.x, nd.y);
        const isActive = hoveredNode ? activeSet.has(nd.id) : true;
        const isCatHighlight = highlightCat ? nd.catKey === highlightCat : true;
        if ((!isActive && hoveredNode) || !isCatHighlight) return;
        const [cr, cg, cb] = hexToRgb(nd.color);
        const baseR = nd.radius * cam.zoom;

        // Each node pulses at its own rhythm
        const pulseCount = nd.type === 'category' ? 2 : 1;
        const pulseSpeed = nd.type === 'category' ? 0.35 : 0.25;
        for (let p = 0; p < pulseCount; p++) {
            const t = ((time * pulseSpeed + nd.phase + p * 0.5) % 1.8) / 1.8;
            if (t > 1) continue;
            const pulseR = baseR * (1.5 + t * 3.5);
            const pulseA = (1 - t) * (nd.type === 'category' ? 0.15 : 0.08);
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, pulseR, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(${cr},${cg},${cb},${pulseA})`;
            ctx.lineWidth = Math.max(0.5, (1 - t) * 2 * cam.zoom);
            ctx.stroke();
        }
    });

    // ── Nodes (3D sphere + living light) ──
    nodes.forEach(nd => {
        const sp = worldToScreen(nd.x, nd.y);
        const breathe = 1 + Math.sin(time * 0.8 + nd.phase) * 0.03;
        const isHovered = nd === hoveredNode;
        const isActive = hoveredNode ? activeSet.has(nd.id) : true;
        const isCatHighlight = highlightCat ? nd.catKey === highlightCat : true;
        const dim = (!isActive && hoveredNode) || !isCatHighlight;
        const baseR = nd.radius * cam.zoom * breathe;
        const r = isHovered ? baseR * 1.15 : baseR;
        const [cr, cg, cb] = hexToRgb(nd.color);

        if (dim) ctx.globalAlpha = 0.08;

        // 1. Drop shadow
        const shGrad = ctx.createRadialGradient(sp.x + r*0.15, sp.y + r*0.2, r*0.3, sp.x + r*0.15, sp.y + r*0.2, r*1.3);
        shGrad.addColorStop(0, 'rgba(0,0,0,0.25)');
        shGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = shGrad;
        ctx.beginPath();
        ctx.arc(sp.x + r*0.15, sp.y + r*0.2, r*1.3, 0, Math.PI*2);
        ctx.fill();

        // 2. Outer glow
        const glowR = r * (nd.type === 'category' ? 3.2 : 2.2);
        const glowA = isHovered ? 0.18 : (nd.type === 'category' ? 0.06 : 0.03);
        const glow = ctx.createRadialGradient(sp.x, sp.y, r*0.5, sp.x, sp.y, glowR);
        glow.addColorStop(0, `rgba(${cr},${cg},${cb},${glowA})`);
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, glowR, 0, Math.PI*2);
        ctx.fill();

        // 3. Sphere body
        const dr = Math.max(cr-50,0), dg = Math.max(cg-50,0), db = Math.max(cb-50,0);
        const lr = Math.min(cr+60,255), lg = Math.min(cg+60,255), lb = Math.min(cb+60,255);

        // Living light: specular position orbits slowly
        const lightSpeed = nd.type === 'category' ? 0.15 : 0.2;
        const lightAngle = time * lightSpeed + nd.phase;
        const lightX = Math.cos(lightAngle) * 0.3;
        const lightY = Math.sin(lightAngle) * 0.3;

        const bodyGrad = ctx.createRadialGradient(
            sp.x + lightX * r, sp.y + lightY * r, r * 0.05,
            sp.x + r * 0.05, sp.y + r * 0.05, r * 1.1
        );
        bodyGrad.addColorStop(0, `rgb(${lr},${lg},${lb})`);
        bodyGrad.addColorStop(0.4, nd.color);
        bodyGrad.addColorStop(1, `rgb(${dr},${dg},${db})`);
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, r, 0, Math.PI*2);
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        // 3.5. Internal pattern (clipped inside sphere, behind glass)
        if (r > 6) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, r * 0.88, 0, Math.PI * 2);
            ctx.clip();
            ctx.globalAlpha = dim ? 0.03 : (isHovered ? 0.55 : 0.3);
            drawPattern(nd.catKey, ctx, sp.x, sp.y, r, time, nd.phase);
            ctx.globalAlpha = dim ? 0.08 : 1;
            ctx.restore();
        }

        // 4. Rim light
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, r, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(${lr},${lg},${lb},${isHovered ? 0.35 : 0.12})`;
        ctx.lineWidth = Math.max(1, r*0.06);
        ctx.stroke();

        // 5. Orbiting specular (living light)
        const specDist = r * 0.3;
        const specX = sp.x + Math.cos(lightAngle) * specDist;
        const specY = sp.y + Math.sin(lightAngle) * specDist;
        const specR = r * 0.3;
        const specGrad = ctx.createRadialGradient(specX, specY, 0, specX, specY, specR);
        specGrad.addColorStop(0, `rgba(255,255,255,${nd.type === 'category' ? 0.5 : 0.35})`);
        specGrad.addColorStop(0.5, 'rgba(255,255,255,0.06)');
        specGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = specGrad;
        ctx.beginPath();
        ctx.arc(specX, specY, specR, 0, Math.PI*2);
        ctx.fill();

        // 6. Hot spot (tiny, follows light)
        const hotX = sp.x + Math.cos(lightAngle) * specDist * 0.7;
        const hotY = sp.y + Math.sin(lightAngle) * specDist * 0.7;
        const hotGrad = ctx.createRadialGradient(hotX, hotY, 0, hotX, hotY, r*0.1);
        hotGrad.addColorStop(0, 'rgba(255,255,255,0.75)');
        hotGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = hotGrad;
        ctx.beginPath();
        ctx.arc(hotX, hotY, r*0.1, 0, Math.PI*2);
        ctx.fill();

        ctx.globalAlpha = 1;
    });


    // ── Labels ──
    nodes.forEach(nd => {
        const sp = worldToScreen(nd.x, nd.y);
        const isHovered = nd === hoveredNode;
        const isActive = hoveredNode ? activeSet.has(nd.id) : true;
        const isCatHighlight = highlightCat ? nd.catKey === highlightCat : true;
        const dim = (!isActive && hoveredNode) || !isCatHighlight;
        const baseR = nd.radius * cam.zoom;

        if (dim) return;

        const showLabel = nd.type === 'category' || isHovered || (cam.zoom > 0.9 && isActive);
        if (!showLabel) return;

        const fontSize = nd.type === 'category' ? Math.max(12, 14 * cam.zoom) : Math.max(10, 11 * cam.zoom);
        const labelY = sp.y + baseR + fontSize + 4;

        ctx.font = `${nd.type === 'category' ? '600' : '500'} ${fontSize}px Inter`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        const tw = ctx.measureText(nd.label).width;
        const pad = 6;

        // Label background
        ctx.fillStyle = 'rgba(3,7,18,0.85)';
        roundRect(ctx, sp.x - tw / 2 - pad, labelY - fontSize / 2 - 3, tw + pad * 2, fontSize + 6, 5);
        ctx.fill();

        // Label text
        ctx.fillStyle = nd.type === 'category' ? '#f1f5f9' : '#cbd5e1';
        ctx.fillText(nd.label, sp.x, labelY);

        // Course count badge for categories
        if (nd.type === 'category') {
            const count = COURSES.filter(c => c.cat === nd.catKey).length;
            const badge = count + '';
            ctx.font = '500 9px "JetBrains Mono"';
            const bw = ctx.measureText(badge).width + 10;
            const bx = sp.x + tw / 2 + pad + 4;
            const by = labelY;
            ctx.fillStyle = nd.color + '30';
            roundRect(ctx, bx - bw / 2, by - 7, bw, 14, 4);
            ctx.fill();
            ctx.fillStyle = nd.color;
            ctx.textAlign = 'center';
            ctx.fillText(badge, bx, by + 1);
        }
    });

    // Zoom label
    document.getElementById('zoom-label').textContent = `zoom ${cam.zoom.toFixed(2)}x`;

    ctx.restore();
}

function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.arcTo(x + w, y, x + w, y + r, r);
    ctx.lineTo(x + w, y + h - r);
    ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
    ctx.lineTo(x + r, y + h);
    ctx.arcTo(x, y + h, x, y + h - r, r);
    ctx.lineTo(x, y + r);
    ctx.arcTo(x, y, x + r, y, r);
    ctx.closePath();
}

// ══════════════════════════════════════════════════
//  INTERACTION
// ══════════════════════════════════════════════════
let dragNode = null;
let isPanning = false;
let panStart = { x: 0, y: 0 };
let mouseX = 0, mouseY = 0;

function findNodeAt(sx, sy) {
    const wp = screenToWorld(sx, sy);
    let best = null, bestD = Infinity;
    // Check in reverse so top-rendered nodes are hit first
    for (let i = nodes.length - 1; i >= 0; i--) {
        const nd = nodes[i];
        const dx = wp.x - nd.x, dy = wp.y - nd.y;
        const d = Math.sqrt(dx * dx + dy * dy);
        const hitR = nd.radius * 1.5 / cam.zoom + 10 / cam.zoom;
        if (d < hitR && d < bestD) { best = nd; bestD = d; }
    }
    return best;
}

canvas.addEventListener('mousedown', e => {
    if (diveDir !== 0) return; // transitioning

    if (diveProgress >= 1) {
        // Inner world — only panning (nodes are orbital)
        isPanning = true;
        panStart = { x: e.clientX, y: e.clientY };
        document.body.classList.add('dragging');
        return;
    }

    const nd = findNodeAt(e.clientX, e.clientY);
    if (nd) {
        dragNode = nd;
        dragNode.pinned = true;
    } else {
        isPanning = true;
        panStart = { x: e.clientX, y: e.clientY };
    }
    document.body.classList.add('dragging');
});

canvas.addEventListener('mousemove', e => {
    mouseX = e.clientX;
    mouseY = e.clientY;

    if (dragNode) {
        const wp = screenToWorld(e.clientX, e.clientY);
        dragNode.x = wp.x;
        dragNode.y = wp.y;
        dragNode.vx = 0;
        dragNode.vy = 0;
        return;
    }

    if (isPanning) {
        const dx = e.clientX - panStart.x;
        const dy = e.clientY - panStart.y;
        if (diveProgress >= 1) {
            innerCam.x -= dx / innerCam.zoom;
            innerCam.y -= dy / innerCam.zoom;
        } else {
            cam.x -= dx / cam.zoom;
            cam.y -= dy / cam.zoom;
            targetCam.x = cam.x;
            targetCam.y = cam.y;
        }
        panStart = { x: e.clientX, y: e.clientY };
        return;
    }

    // Inner world hover
    if (diveProgress >= 1) {
        const nd = findInnerNodeAt(e.clientX, e.clientY);
        if (nd !== innerHovered) {
            innerHovered = nd;
            canvas.style.cursor = nd ? 'pointer' : 'grab';
            if (nd) {
                updateTooltip(nd, e.clientX, e.clientY);
            } else {
                document.getElementById('tooltip').classList.remove('visible');
            }
        } else if (nd) {
            updateTooltip(nd, e.clientX, e.clientY);
        }
        return;
    }

    // Network hover detection
    const nd = findNodeAt(e.clientX, e.clientY);
    if (nd !== hoveredNode) {
        hoveredNode = nd;
        canvas.style.cursor = nd ? 'pointer' : 'grab';
        updateTooltip(nd, e.clientX, e.clientY);
    } else if (nd) {
        updateTooltip(nd, e.clientX, e.clientY);
    }
});

canvas.addEventListener('mouseup', () => {
    if (dragNode) {
        dragNode.pinned = false;
        dragNode = null;
    }
    isPanning = false;
    document.body.classList.remove('dragging');
});

canvas.addEventListener('mouseleave', () => {
    hoveredNode = null;
    innerHovered = null;
    document.getElementById('tooltip').classList.remove('visible');
    isPanning = false;
    dragNode = null;
    document.body.classList.remove('dragging');
});

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    if (diveDir !== 0) return; // transitioning

    const zoomFactor = e.deltaY > 0 ? 0.92 : 1.08;

    if (diveProgress >= 1) {
        // Inner world zoom toward mouse
        const newZoom = Math.max(0.4, Math.min(3, innerCam.zoom * zoomFactor));
        const wp = innerScreenToWorld(e.clientX, e.clientY);
        innerCam.zoom = newZoom;
        const wpAfter = innerScreenToWorld(e.clientX, e.clientY);
        innerCam.x -= (wpAfter.x - wp.x);
        innerCam.y -= (wpAfter.y - wp.y);

        // Zoom out far enough → dive out
        if (innerCam.zoom <= 0.42) diveOut();
        return;
    }

    const newZoom = Math.max(0.2, Math.min(6, cam.zoom * zoomFactor));

    // Zoom toward mouse
    const wp = screenToWorld(e.clientX, e.clientY);
    cam.zoom = newZoom;
    const wpAfter = screenToWorld(e.clientX, e.clientY);
    cam.x -= (wpAfter.x - wp.x);
    cam.y -= (wpAfter.y - wp.y);
    targetCam.x = cam.x;
    targetCam.y = cam.y;
    targetCam.zoom = cam.zoom;

    // Auto-dive: zoom in very close on a category node → dive in
    if (cam.zoom > 4.5) {
        const nd = findNodeAt(e.clientX, e.clientY);
        if (nd && nd.type === 'category') {
            diveInto(nd);
        }
    }
}, { passive: false });

// Touch support
let lastTouchDist = 0;
let touchPanStart = null;
canvas.addEventListener('touchstart', e => {
    if (diveDir !== 0) { e.preventDefault(); return; }
    if (e.touches.length === 1) {
        const t = e.touches[0];
        if (diveProgress >= 1) {
            isPanning = true; touchPanStart = { x: t.clientX, y: t.clientY };
        } else {
            const nd = findNodeAt(t.clientX, t.clientY);
            if (nd) { dragNode = nd; dragNode.pinned = true; }
            else { isPanning = true; touchPanStart = { x: t.clientX, y: t.clientY }; }
        }
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx * dx + dy * dy);
    }
    e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 1) {
        const t = e.touches[0];
        if (dragNode) {
            const wp = screenToWorld(t.clientX, t.clientY);
            dragNode.x = wp.x; dragNode.y = wp.y;
        } else if (isPanning && touchPanStart) {
            const dx = t.clientX - touchPanStart.x;
            const dy = t.clientY - touchPanStart.y;
            if (diveProgress >= 1) {
                innerCam.x -= dx / innerCam.zoom;
                innerCam.y -= dy / innerCam.zoom;
            } else {
                cam.x -= dx / cam.zoom; cam.y -= dy / cam.zoom;
                targetCam.x = cam.x; targetCam.y = cam.y;
            }
            touchPanStart = { x: t.clientX, y: t.clientY };
        }
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (lastTouchDist > 0) {
            const scale = dist / lastTouchDist;
            if (diveProgress >= 1) {
                innerCam.zoom = Math.max(0.4, Math.min(3, innerCam.zoom * scale));
                if (innerCam.zoom <= 0.42) diveOut();
            } else {
                cam.zoom = Math.max(0.2, Math.min(6, cam.zoom * scale));
                targetCam.zoom = cam.zoom;
            }
        }
        lastTouchDist = dist;
    }
    e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', e => {
    if (dragNode) { dragNode.pinned = false; dragNode = null; }
    isPanning = false; touchPanStart = null; lastTouchDist = 0;
});

// Double-click to focus / dive
canvas.addEventListener('dblclick', e => {
    if (diveDir !== 0) return; // transitioning

    if (diveProgress >= 1) {
        // In inner world — double-click empty space to dive out
        const nd = findInnerNodeAt(e.clientX, e.clientY);
        if (!nd) diveOut();
        return;
    }

    const nd = findNodeAt(e.clientX, e.clientY);
    if (nd && nd.type === 'category') {
        diveInto(nd);
    } else if (nd) {
        targetCam.x = nd.x;
        targetCam.y = nd.y;
        targetCam.zoom = 2;
    } else {
        resetView();
    }
});

// ══════════════════════════════════════════════════
//  TOOLTIP
// ══════════════════════════════════════════════════
function updateTooltip(nd, mx, my) {
    const tip = document.getElementById('tooltip');
    if (!nd) { tip.classList.remove('visible'); return; }

    tip.classList.add('visible');
    const catInfo = CATEGORIES[nd.catKey];

    if (nd.type === 'category') {
        const count = COURSES.filter(c => c.cat === nd.catKey).length;
        tip.querySelector('.cat').textContent = '';
        tip.querySelector('.cat').style.color = nd.color;
        tip.querySelector('.title').textContent = catInfo.name;
        tip.querySelector('.desc').textContent = `${count} cursos en esta área`;
        tip.querySelector('.badge').textContent = 'categoría';
    } else {
        tip.querySelector('.cat').textContent = catInfo.name;
        tip.querySelector('.cat').style.color = nd.color;
        tip.querySelector('.title').textContent = nd.label;
        tip.querySelector('.desc').textContent = nd.desc || '';
        tip.querySelector('.badge').textContent = 'curso';
    }

    // Position
    let tx = mx + 16, ty = my - 10;
    if (tx + 270 > W) tx = mx - 270;
    if (ty + 120 > H) ty = my - 120;
    tip.style.left = tx + 'px';
    tip.style.top = ty + 'px';
    tip.style.borderColor = nd.color + '40';
}

// ══════════════════════════════════════════════════
//  LEGEND
// ══════════════════════════════════════════════════
function buildLegend() {
    const el = document.getElementById('legend');
    el.innerHTML = '';
    catKeys.forEach(key => {
        const cat = CATEGORIES[key];
        const count = COURSES.filter(c => c.cat === key).length;
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `<div class="legend-dot" style="background:${cat.color}"></div>
            <span>${cat.name}</span><span class="legend-count">${count}</span>`;
        item.addEventListener('click', () => {
            if (highlightCat === key) highlightCat = null;
            else highlightCat = key;
            el.querySelectorAll('.legend-item').forEach((it, i) => {
                it.classList.toggle('dimmed', highlightCat && catKeys[i] !== highlightCat);
            });
        });
        el.appendChild(item);
    });
}
buildLegend();

// ══════════════════════════════════════════════════
//  CONTROLS
// ══════════════════════════════════════════════════
function togglePhysics() {
    physicsOn = !physicsOn;
    document.getElementById('btnPhysics').classList.toggle('active', physicsOn);
    document.getElementById('btnPhysics').textContent = physicsOn ? 'Física' : 'Física OFF';
}

// ── TOUR ──
let tourRunning = false;
let tourStep = -1;
let tourTimer = null;

function startTour() {
    if (tourRunning) { stopTour(); return; }
    tourRunning = true;
    tourStep = -1;
    document.getElementById('btnTour').classList.add('active');
    document.getElementById('btnTour').textContent = 'Stop';
    nextTourStop();
}

function stopTour() {
    tourRunning = false;
    tourStep = -1;
    highlightCat = null;
    clearTimeout(tourTimer);
    document.getElementById('btnTour').classList.remove('active');
    document.getElementById('btnTour').textContent = 'Tour';
    // Rebuild legend state
    document.querySelectorAll('.legend-item').forEach(it => it.classList.remove('dimmed'));
    resetView();
}

function nextTourStop() {
    if (!tourRunning) return;
    tourStep++;

    if (tourStep >= catKeys.length) {
        // Final: zoom out to full view
        highlightCat = null;
        document.querySelectorAll('.legend-item').forEach(it => it.classList.remove('dimmed'));
        resetView();
        tourTimer = setTimeout(() => stopTour(), 2000);
        return;
    }

    const key = catKeys[tourStep];
    const hub = nodeMap['cat-' + key];

    // Highlight this category
    highlightCat = key;
    document.querySelectorAll('.legend-item').forEach((it, i) => {
        it.classList.toggle('dimmed', catKeys[i] !== key);
    });

    // Fly camera to this category hub
    targetCam.x = hub.x;
    targetCam.y = hub.y;
    targetCam.zoom = 2.2;

    // Wait, then advance
    tourTimer = setTimeout(() => nextTourStop(), 3200);
}

// ── SHUFFLE ──
function shuffle() {
    // Cancel tour if running
    if (tourRunning) stopTour();

    const spread = Math.min(W, H) * 0.5;
    nodes.forEach(nd => {
        if (nd.pinned) return;
        nd.x = (Math.random() - 0.5) * spread * (nd.type === 'category' ? 1.5 : 2);
        nd.y = (Math.random() - 0.5) * spread * (nd.type === 'category' ? 1.5 : 2);
        nd.vx = 0;
        nd.vy = 0;
    });

    // Make sure physics is on so it re-settles
    if (!physicsOn) {
        physicsOn = true;
        document.getElementById('btnPhysics').classList.add('active');
        document.getElementById('btnPhysics').textContent = 'Física';
    }

    resetView();
}

// ══════════════════════════════════════════════════
//  DIVE SYSTEM (Google Maps-style zoom into worlds)
// ══════════════════════════════════════════════════
let diveNode = null;        // category node we're inside
let diveProgress = 0;       // 0=network, 1=inner world
let diveDir = 0;            // 1=diving in, -1=diving out, 0=idle
let innerNodes = [];        // course nodes in inner world
let innerCam = { x: 0, y: 0, zoom: 1 };
let innerHovered = null;
let innerDragNode = null;

function diveInto(catNode) {
    if (diveNode || diveDir !== 0) return;
    if (tourRunning) stopTour();
    diveNode = catNode;
    diveDir = 1;
    diveProgress = 0;
    hoveredNode = null;
    highlightCat = null;
    document.getElementById('tooltip').classList.remove('visible');
    document.querySelectorAll('.legend-item').forEach(it => it.classList.remove('dimmed'));

    // Create inner world nodes
    const courses = COURSES.filter(c => c.cat === catNode.catKey);
    const count = courses.length;
    innerNodes = courses.map((c, i) => {
        const angle = (i / count) * Math.PI * 2 - Math.PI / 2;
        const orbitR = 160 + count * 12;
        return {
            id: c.id, label: c.name, desc: c.desc,
            catKey: c.cat, color: catNode.color,
            x: Math.cos(angle) * orbitR,
            y: Math.sin(angle) * orbitR,
            radius: 22, phase: Math.random() * Math.PI * 2,
            baseAngle: angle, orbitR,
            type: 'course'
        };
    });
    innerCam = { x: 0, y: 0, zoom: 1 };
}

function diveOut() {
    if (!diveNode || diveDir !== 0) return;
    diveDir = -1;
}

function innerWorldToScreen(wx, wy) {
    return {
        x: (wx - innerCam.x) * innerCam.zoom + W / 2,
        y: (wy - innerCam.y) * innerCam.zoom + H / 2
    };
}
function innerScreenToWorld(sx, sy) {
    return {
        x: (sx - W / 2) / innerCam.zoom + innerCam.x,
        y: (sy - H / 2) / innerCam.zoom + innerCam.y
    };
}

function getInnerDisplayPos(nd) {
    const drift = Math.sin(time * 0.3 + nd.phase) * 8;
    const driftY = Math.cos(time * 0.25 + nd.phase * 1.3) * 6;
    return { x: nd.x + drift, y: nd.y + driftY };
}

function findInnerNodeAt(sx, sy) {
    const wp = innerScreenToWorld(sx, sy);
    let best = null, bestD = Infinity;
    for (let i = innerNodes.length - 1; i >= 0; i--) {
        const nd = innerNodes[i];
        const dp = getInnerDisplayPos(nd);
        const dx = wp.x - dp.x, dy = wp.y - dp.y;
        const d = Math.sqrt(dx * dx + dy * dy);
        const hitR = nd.radius * 1.5 / innerCam.zoom + 10 / innerCam.zoom;
        if (d < hitR && d < bestD) { best = nd; bestD = d; }
    }
    return best;
}

function renderInnerWorld(alpha) {
    if (!diveNode) return;
    ctx.save();
    ctx.globalAlpha = alpha;

    const [cr, cg, cb] = hexToRgb(diveNode.color);
    const catKey = diveNode.catKey;

    // Background
    ctx.fillStyle = '#030712';
    ctx.fillRect(0, 0, W, H);

    // Category-colored nebula background
    for (let i = 0; i < 4; i++) {
        const nx = W * (0.2 + i * 0.2) + Math.sin(time * 0.1 + i) * 40;
        const ny = H * (0.3 + (i % 2) * 0.4) + Math.cos(time * 0.08 + i) * 30;
        const nr = W * (0.25 + i * 0.05);
        const grad = ctx.createRadialGradient(nx, ny, 0, nx, ny, nr);
        grad.addColorStop(0, `rgba(${cr},${cg},${cb},${0.05 - i * 0.01})`);
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);
    }

    // Full-screen pattern (category's pattern as background)
    ctx.globalAlpha = alpha * 0.12;
    drawPattern(catKey, ctx, W / 2, H / 2, Math.min(W, H) * 0.45, time, diveNode.phase);
    ctx.globalAlpha = alpha;

    // Stars in inner world
    for (let i = 0; i < 80; i++) {
        const sx = ((i * 137.5 + 50) % W);
        const sy = ((i * 97.3 + 30) % H);
        const twk = 0.4 + 0.6 * Math.sin(time * 0.5 + i * 0.7);
        ctx.globalAlpha = alpha * 0.3 * twk;
        ctx.fillStyle = `rgb(${cr},${cg},${cb})`;
        ctx.beginPath();
        ctx.arc(sx, sy, 1, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = alpha;

    // Category title (subtle, since header already shows info)
    ctx.font = '300 28px Inter';
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(${cr},${cg},${cb},0.15)`;
    ctx.fillText(CATEGORIES[catKey].name, W / 2, H / 2);
    ctx.font = '400 11px "JetBrains Mono"';
    ctx.fillStyle = 'rgba(148,163,184,0.25)';
    ctx.fillText(`${innerNodes.length} cursos`, W / 2, H / 2 + 22);

    // Connections from center to courses
    innerNodes.forEach(nd => {
        const sp = innerWorldToScreen(nd.x, nd.y);
        ctx.beginPath();
        ctx.moveTo(W / 2, H / 2);
        ctx.lineTo(sp.x, sp.y);
        ctx.strokeStyle = `rgba(${cr},${cg},${cb},0.06)`;
        ctx.lineWidth = 1;
        ctx.stroke();

        // Edge particle
        const tt = ((time * 0.15 + nd.phase * 0.3) % 1);
        const px = W / 2 + (sp.x - W / 2) * tt;
        const py = H / 2 + (sp.y - H / 2) * tt;
        ctx.beginPath();
        ctx.arc(px, py, 1.5, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${cr},${cg},${cb},${0.3 * (0.5 + 0.5 * Math.sin(tt * Math.PI))})`;
        ctx.fill();
    });

    // Central glow (category hub representation)
    const centerGlow = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, 60);
    centerGlow.addColorStop(0, `rgba(${cr},${cg},${cb},0.15)`);
    centerGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = centerGlow;
    ctx.beginPath();
    ctx.arc(W/2, H/2, 60, 0, Math.PI * 2);
    ctx.fill();

    // Pulse waves from center
    for (let p = 0; p < 2; p++) {
        const t = ((time * 0.2 + p * 0.5) % 2) / 2;
        if (t > 1) continue;
        const pr = 30 + t * 200;
        ctx.beginPath();
        ctx.arc(W/2, H/2, pr, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(${cr},${cg},${cb},${(1-t) * 0.1})`;
        ctx.lineWidth = (1 - t) * 2;
        ctx.stroke();
    }

    // Course nodes — gentle orbital drift
    innerNodes.forEach(nd => {
        const drift = Math.sin(time * 0.3 + nd.phase) * 8;
        const driftY = Math.cos(time * 0.25 + nd.phase * 1.3) * 6;
        const displayX = nd.x + drift;
        const displayY = nd.y + driftY;
        const sp = innerWorldToScreen(displayX, displayY);
        const r = nd.radius * innerCam.zoom;
        const isHov = nd === innerHovered;
        const drawR = isHov ? r * 1.15 : r;

        // Pulse wave per course
        const pt = ((time * 0.25 + nd.phase) % 1.8) / 1.8;
        if (pt < 1) {
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, drawR * (1.3 + pt * 2.5), 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(${cr},${cg},${cb},${(1-pt) * 0.1})`;
            ctx.lineWidth = (1 - pt) * 1.5;
            ctx.stroke();
        }

        // Glow
        const gGrad = ctx.createRadialGradient(sp.x, sp.y, drawR * 0.3, sp.x, sp.y, drawR * 2.5);
        gGrad.addColorStop(0, `rgba(${cr},${cg},${cb},${isHov ? 0.15 : 0.05})`);
        gGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = gGrad;
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, drawR * 2.5, 0, Math.PI * 2);
        ctx.fill();

        // Sphere body
        const dr = Math.max(cr-50,0), dg = Math.max(cg-50,0), db = Math.max(cb-50,0);
        const lr = Math.min(cr+60,255), lg = Math.min(cg+60,255), lb = Math.min(cb+60,255);
        const la = time * 0.2 + nd.phase;
        const lx = Math.cos(la) * 0.3, ly = Math.sin(la) * 0.3;
        const bGrad = ctx.createRadialGradient(sp.x+lx*drawR, sp.y+ly*drawR, drawR*0.05, sp.x+drawR*0.05, sp.y+drawR*0.05, drawR*1.1);
        bGrad.addColorStop(0, `rgb(${lr},${lg},${lb})`);
        bGrad.addColorStop(0.4, diveNode.color);
        bGrad.addColorStop(1, `rgb(${dr},${dg},${db})`);
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, drawR, 0, Math.PI * 2);
        ctx.fillStyle = bGrad;
        ctx.fill();

        // Internal pattern
        if (drawR > 8) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, drawR * 0.88, 0, Math.PI * 2);
            ctx.clip();
            ctx.globalAlpha = alpha * (isHov ? 0.5 : 0.25);
            drawPattern(catKey, ctx, sp.x, sp.y, drawR, time, nd.phase);
            ctx.globalAlpha = alpha;
            ctx.restore();
        }

        // Rim + specular
        ctx.beginPath();
        ctx.arc(sp.x, sp.y, drawR, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(${lr},${lg},${lb},${isHov ? 0.35 : 0.12})`;
        ctx.lineWidth = Math.max(1, drawR * 0.06);
        ctx.stroke();

        const specX = sp.x + Math.cos(la) * drawR * 0.3;
        const specY = sp.y + Math.sin(la) * drawR * 0.3;
        const sGrad = ctx.createRadialGradient(specX, specY, 0, specX, specY, drawR * 0.3);
        sGrad.addColorStop(0, 'rgba(255,255,255,0.4)');
        sGrad.addColorStop(0.5, 'rgba(255,255,255,0.05)');
        sGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = sGrad;
        ctx.beginPath();
        ctx.arc(specX, specY, drawR * 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Label (always visible in inner world)
        const fontSize = Math.max(11, 13 * innerCam.zoom);
        const labelY = sp.y + drawR + fontSize + 6;
        ctx.font = `500 ${fontSize}px Inter`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const tw = ctx.measureText(nd.label).width;
        ctx.fillStyle = 'rgba(3,7,18,0.85)';
        roundRect(ctx, sp.x - tw/2 - 6, labelY - fontSize/2 - 3, tw + 12, fontSize + 6, 5);
        ctx.fill();
        ctx.fillStyle = isHov ? '#f1f5f9' : '#cbd5e1';
        ctx.fillText(nd.label, sp.x, labelY);

        // Description on hover
        if (isHov && nd.desc) {
            const descY = labelY + fontSize + 10;
            ctx.font = `400 ${Math.max(10, 11 * innerCam.zoom)}px Inter`;
            const dtw = Math.min(ctx.measureText(nd.desc).width, 220);
            ctx.fillStyle = 'rgba(3,7,18,0.9)';
            roundRect(ctx, sp.x - dtw/2 - 8, descY - 8, dtw + 16, 22, 5);
            ctx.fill();
            ctx.fillStyle = '#94a3b8';
            ctx.fillText(nd.desc.length > 45 ? nd.desc.slice(0, 42) + '...' : nd.desc, sp.x, descY + 3);
        }
    });

    // Vignette
    const vig = ctx.createRadialGradient(W/2, H/2, W*0.2, W/2, H/2, W*0.75);
    vig.addColorStop(0, 'transparent');
    vig.addColorStop(1, `rgba(${Math.floor(cr*0.1)},${Math.floor(cg*0.1)},${Math.floor(cb*0.1)},0.6)`);
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, W, H);

    ctx.restore();
}

// ══════════════════════════════════════════════════
//  ANIMATION LOOP
// ══════════════════════════════════════════════════
function animate(ts) {
    time = ts / 1000;

    // Dive transition
    if (diveDir === 1) {
        diveProgress = Math.min(1, diveProgress + 0.02);
        if (diveProgress >= 1) diveDir = 0;
        // Zoom camera into the category node (Google Maps effect)
        if (diveNode) {
            targetCam.x = diveNode.x;
            targetCam.y = diveNode.y;
            targetCam.zoom = 1 + diveProgress * 5;
        }
    } else if (diveDir === -1) {
        diveProgress = Math.max(0, diveProgress - 0.025);
        if (diveProgress <= 0) {
            diveDir = 0; diveNode = null; innerNodes = [];
            innerHovered = null;
            resetView();
        }
    }

    // UI visibility during dive
    const legendEl = document.getElementById('legend');
    const controlsEl = document.getElementById('controls');
    const subEl = document.getElementById('headerSub');
    if (diveProgress > 0) {
        const fade = 1 - diveProgress;
        legendEl.style.opacity = fade;
        legendEl.style.pointerEvents = diveProgress > 0.5 ? 'none' : '';
        controlsEl.style.opacity = fade;
        controlsEl.style.pointerEvents = diveProgress > 0.5 ? 'none' : '';
        if (diveNode && diveProgress >= 1) {
            subEl.textContent = `${CATEGORIES[diveNode.catKey].name} · ${innerNodes.length} cursos · doble-click para volver · scroll zoom`;
        }
    } else {
        legendEl.style.opacity = 1;
        legendEl.style.pointerEvents = '';
        controlsEl.style.opacity = 1;
        controlsEl.style.pointerEvents = '';
        subEl.textContent = 'network graph · 37 cursos · 9 áreas · scroll zoom · doble-click categoría para explorar';
    }

    // Smooth camera
    cam.x += (targetCam.x - cam.x) * 0.06;
    cam.y += (targetCam.y - cam.y) * 0.06;
    cam.zoom += (targetCam.zoom - cam.zoom) * 0.06;

    simulate();

    if (diveProgress <= 0) {
        render();
    } else if (diveProgress >= 1) {
        renderInnerWorld(1);
    } else {
        // Blend: render network fading out, inner world fading in
        const ease = diveProgress * diveProgress * (3 - 2 * diveProgress); // smoothstep
        ctx.globalAlpha = 1 - ease * 0.3;
        render();
        ctx.globalAlpha = 1;
        renderInnerWorld(ease);
    }

    requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
</script>
</body>
</html>
